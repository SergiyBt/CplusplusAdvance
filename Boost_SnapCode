#include <iostream>
#include <string>
#include <boost\lexical_cast.hpp>
#include <array>

using namespace std;
using boost::lexical_cast;
using boost::bad_lexical_cast;

///////////////////////////////////////////////////////// USING LEXICAL_CAST<>() /////////////////////////////////////////////////////

int main(){

  int a = 39;
  string str = lexical_cast<string>(a) + lexical_cast<string>('s') + lexical_cast<string>("34.5");
  cout<<str<<"\n";
  array<char,10> arr;
  string b = "3242sdfs";

	arr = lexical_cast< array<char,10> >(b);

	for(auto i : arr){
	cout<<i<<"\n";
	}

	try{
	   a = lexical_cast<int>("345rt");
	}catch(bad_lexical_cast &exp){
		cout<<exp.what()<<"\n";
	}

	a = lexical_cast<int>("43654mmm",5);

	cout<<a<<"\n";
	
_getch();
return 0;
}

//////////////////////////////////////////////// USING VARIANT INSTEAD UNION /////////////////////////////////////////////////////////

#include <iostream>
#include <string>
#include <boost\variant.hpp>
#include <vector>

using namespace std;

class DoubleWrapVisitor : public boost::static_visitor<> {
public:
	void operator()(int& i) const {
	// just samething do
		i += i;
	}
	void operator()(string& s) const{
	// just samething do	
		s += s;
	}
};

int main(){

	union  { int i; float f; } u;
	u.i = 34;
	cout << u.i <<"\n" << u.f <<"\n";
	u.f = 45.6; // ovverride
	cout << u.f <<"\n" << u.i <<"\n";

	boost::variant<int,string> u1,u2;
	u1 = 34;
	u2 = "ssgfgdvfd";
	cout<< u1 << "  " << u2 << "\n";
	u2 = 89;

	int s = boost::get<int>(u1)*boost::get<int>(u2) + 2;
	cout<< s << "\n";

	try {
	string str = boost::get<string>(u2);
	}

	catch(boost::bad_get &get){
		cout<<get.what()<<" \n ";
	}

	boost::variant<int,string> u3;
	cout<< u3 << "\n";

	u3 = 67;
	DoubleWrapVisitor dv;
	boost::apply_visitor(dv,u3);
	cout<< u3 << "\n";
	u3 = "bad";
	boost::apply_visitor(dv,u3);
	cout<< u3 << "\n";

	vector< boost::variant<int,string> > vec;
	vec.push_back("sfdfds");
	vec.push_back(34);

	for(auto i : vec){
		boost::apply_visitor(dv,i);
	}

_getch();
return 0;
}

///////////////////////////////////////////// USING ANY ////////////////////////////////////////////////////////////////////////////////
#include <iostream>
#include <string>
#include <boost\any.hpp>
#include <vector>

using namespace std;

struct Data{
	string name;
	boost::any value;
};

int main(){

	boost::any a,b,c,d;
	a = string("hellow");
	b = 34.5f;
	c = 'f';
	d = vector<int>();

	cout<<boost::any_cast<string>(a)<<"\n"<<
		  boost::any_cast<float>(b)<<"\n"<<
		  boost::any_cast<char>(c)<<"\n";

	if(c.type() == typeid(char))
		cout<<" variable c containes char value "<<endl;
		  
	boost::any_cast< vector<int> >(d).push_back(23);

	int i;
	boost::any p = &i; 
	int* ptr = boost::any_cast<int*>(p);

	vector<boost::any> vec;
	vec.push_back(56);
	vec.push_back('r');
	vec.push_back(p);
	vec.push_back(boost::any());

	vector<Data> vec2; 

_getch();
return 0;
}

////////////////////////////////// USING OPTIONAL //////////////////////////////////////////////////////////////////////////////////
#include <iostream>
#include <boost/optional.hpp>
#include <deque>

using namespace std;

boost::optional<char> print_char_qeue(deque<char> &a){
	if(!a.empty()){
		return boost::optional<char>(a.back());		
	} else
		return boost::optional<char>();
}

struct A {
	int value; 
	string name;
};

int main(){

	deque<char> queue;
	
	//for(int i=0; i<10; i++){
	//	queue.push_back('A' + i);
	//}
	
	//char a;
	
	//for(int i=0; i<10; i++){
	//  a = queue.back(); 
	//	queue.pop_back();
	//	cout<<a<<"\n";
	//}


	boost::optional<char> op;	
	op = print_char_qeue(queue);
		if(!op)
			cout<<" Data is not avalible ! \n";
		else cout<<op.get()<<"\n";	

		op.reset();
		cout<<op.get_value_or('A')<<"\n";
		//op.reset();

		//char* a = op.get_ptr();

		
		A stA;
		//boost::optional<A> op;	
		//boost::optional<A> op(stA);

		boost::optional<A*> op2(&stA);
		(*op2)->name = "sdfdfs";
		(*op2)->value = 12;

		cout<<stA.name<<" "<<stA.value<<" "<<"\n";

		boost::optional<A&> op3(stA);
		op3->name = "ggggg";
		op3->value = 45;

		cout<<stA.name<<" "<<stA.value<<" "<<"\n";

_getch();
return 0;
}




